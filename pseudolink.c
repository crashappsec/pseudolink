/* pseudolink.c
 *
 * Bundle dynamic dependencies for OS X into a C object file that
 * automatically writes them to the filesystem before the dynamlic
 * linker looks for them.
 *
 * Author: John Viega (john@crashoverride.com)
 * Copyright 2023, Crash Override, Inc.
 * Released under the terms of the Apache License.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const char  hex_map[] = "0123456789abcdef";
const char *prefix =
    "/* Generated by pseudolink.\n"
    "** Pseudolink and generated code are Copyright 2023, CrashOverride Inc.\n"
    "** and licensed under the Apache License.\n"
    "**/\n"
    "\n"
    "#include <stdlib.h>\n"
    "#include <stdio.h>\n"
    "#include <unistd.h>\n"
    "#include <string.h>\n"
    "#include <errno.h>\n"
    "#include <sys/stat.h>\n"
    "#include <libproc.h>\n"
    "\n"
    "#define DYLD_ENVVAR \"DYLD_LIBRARY_PATH\"\n"
    "#define DYLD_PREFIX \"DYLD_LIBRARY_PATH=\"\n"
    "\n"
    "#define PATHLEN PROC_PIDPATHINFO_MAXSIZE\n"
    "\n";

const char *postfix =
    "char *\n"
    "get_dyld_lib_dir()\n"
    "{\n"
    "    char *outbuf = (char *)malloc(PATHLEN);\n"
    "    snprintf(outbuf, PATHLEN, \"/tmp/dyld_lib_files_%d/\", getuid());\n"
    "\n"
    "    return outbuf;\n"
    "}\n"
    "\n"
    "char *\n"
    "construct_dyld_entry(char *dyld_path)\n"
    "{\n"
    "    char *entry = (char *)malloc(strlen(dyld_path) + \n"
    "                                 strlen(DYLD_PREFIX) + 1);\n"
    "\n"
    "    strcpy(entry, DYLD_PREFIX);\n"
    "    strcat(entry, dyld_path);\n"
    "\n"
    "    return entry;\n"
    "}\n"
    "\n"
    "char **\n"
    "get_new_envp(char **envp, size_t old_sz, char *dir)\n"
    "{\n"
    "    char   **new_envp = malloc(old_sz + sizeof(char *));\n"
    "    char   **p        = envp;\n"
    "    char   **q        = new_envp;\n"
    "    size_t   n        = strlen(DYLD_PREFIX);\n"
    "\n"
    "    while (*p) {\n"
    "      if (strncmp(*p, DYLD_PREFIX, n)) {\n"
    "          *q++ = *p++;\n"
    "      } else {\n"
    "          p++;\n"
    "      }\n"
    "    }\n"
    "\n"
    "    *q++ = construct_dyld_entry(dir);\n"
    "    *q   = 0;\n"
    "\n"
    "    return new_envp;\n"
    "}\n"
    "\n"
    "char *\n"
    "setup_dyld_dir(int *need_execing)\n"
    "{\n"
    "    struct stat info;\n"
    "    char        path[PATHLEN];\n"
    "    char       *dyld_dir = get_dyld_lib_dir();\n"
    "    char       *p        = path + strlen(dyld_dir);\n"
    "    int         maxlen   = 512 - strlen(dyld_dir) - 1;\n"
    "    int         i;\n"
    "    int         len;\n"
    "    FILE       *f;\n"
    "\n"
    "    *need_execing = 0;\n"
    "\n"
    "    strcpy(path, dyld_dir);\n"
    "\n"
    "    if (stat(dyld_dir, &info) == -1) {\n"
    "        if (errno != ENOENT) {\n"
    "            goto error;\n"
    "        }\n"
    "        if (mkdir(dyld_dir, 0700)) {\n"
    "            goto error;\n"
    "        }\n"
    "        *need_execing = 1;\n"
    "    }\n"
    "\n"
    "    for (i = 0; i < dyld_num_libs; i++) {\n"
    "        strncpy(p, dyld_library_names[i], maxlen);\n"
    "\n"
    "        if (stat(path, &info) == -1) {\n"
    "            *need_execing = 1;\n"
    "            f             = fopen(path, \"wb\");\n"
    "\n"
    "            if (f == NULL) {\n"
    "                goto error;\n"
    "            }\n"
    "            fwrite(dyld_library_files[i], dyld_library_lens[i], 1, f);\n"
    "            fclose(f);\n"
    "        }\n"
    "    }\n"
    "\n"
    "    return dyld_dir;\n"
    "\n"
    "error:\n"
    "    fprintf(stderr, \"Couldn't build tmp dylib directory.\\n\");"
    "    _exit(1);\n"
    "}\n"
    "\n"
    "__attribute__((constructor (101))) void\n"
    "pre_main_dyld_dropper(int argc, char **argv, char **envp)\n"
    "{\n"
    "    char **p        = envp;\n"
    "    char **dyld_p   = NULL;\n"
    "    char  *dyld_dir = NULL;\n"
    "    char  *found_dir;\n"
    "    int    exec;\n"
    "\n"
    "    dyld_dir  = setup_dyld_dir(&exec);\n"
    "    found_dir = getenv(DYLD_ENVVAR);\n"
    "\n"
    "    if (exec || !found_dir || strcmp(dyld_dir, found_dir)) { \n"
    "      int pid = getpid();\n"
    "      char cmdname[PATHLEN];\n"
    "      proc_pidpath(pid, cmdname, PATHLEN);\n"
    "      execve(cmdname, argv, get_new_envp(envp, sizeof(envp), dyld_dir));\n"
    "    }\n"
    "    free(dyld_dir);\n"
    "}\n";

int
main(int argc, char *argv[])
{
    FILE *outfile  = fopen("dyld_decls.c", "wb");
    int  *len_info = (int *)malloc(sizeof(int) * argc);
    int   i;

    if (!outfile) {
        fprintf(stderr, "Couldn't open output file dyld_decls.c");
        exit(1);
    }

    fprintf(outfile, "%s", prefix);

    for (i = 1; i < argc; i++) {
        FILE *f = fopen(argv[i], "rb");
        char *contents;
        int   sz;

        if (!f) {
            fprintf(stderr, "Couldn't open %s\n", argv[i]);
            exit(1);
        }

        fseek(f, 0, SEEK_END);
        sz              = ftell(f);
        contents        = (char *)malloc(sz);
        len_info[i - 1] = sz;
        fseek(f, 0, SEEK_SET);
        fread(contents, sz, 1, f);
        fclose(f);

        fprintf(outfile, "const char dylib_%d[] = \"", i);

        for (int ix = 0; ix < sz; ix++) {
            char c = contents[ix];
            putc('\\', outfile);
            putc('x', outfile);
            putc(hex_map[(c >> 4) & 0x0f], outfile);
            putc(hex_map[c & 0x0f], outfile);
        }
        fprintf(outfile, "\";\n");
    }

    fprintf(outfile, "const char *dyld_library_names[] = {\n");

    for (i = 1; i < argc; i++) {
        char *p = strrchr(argv[i], '/');
        if (p == NULL) {
            p = argv[i];
        } else {
            p++;
        }
        fprintf(outfile, "\"%s\", ", p);
    }
    fprintf(outfile, "0 };\nconst char *dyld_library_files[] = {\n");
    for (i = 1; i < argc; i++) {
        fprintf(outfile, " dylib_%d, ", i);
    }
    fprintf(outfile, "0 };\nconst int dyld_library_lens[] = {\n");
    for (i = 0; i < argc - 1; i++) {
        fprintf(outfile, "%d, ", len_info[i]);
    }
    fprintf(outfile, "0 };\nint dyld_num_libs = %d;\n", argc - 1);

    fprintf(outfile, "\n%s", postfix);

    fprintf(stderr, "Output bundled dylibs in dyld_decls.c.\n");
    fprintf(stderr, "Compile and link that file to your program.\n");

    return 0;
}
